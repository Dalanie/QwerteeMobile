package com.qwertee.general;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.logging.Level;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import melb.msafe.jdispatcher.jdispatch.Dispatcher;
import melb.msafe.jdispatcher.jdispatch.HttpMethod;
import melb.msafe.jdispatcher.jdispatch.ResourceHandler;
import melb.msafe.jdispatcher.jdispatch.exceptions.UnexpectedException;
import melb.msafe.resources.FAQResource;
import melb.msafe.resources.GeneralResource;
import melb.msafe.resources.LastChanceResource;
import melb.msafe.resources.PreviousResource;
import melb.msafe.resources.TodayResource;
import melb.msafe.resources.VoteResource;

import com.google.gson.Gson;

/**
 * This class is responsible for mapping the incoming URI-requests from clients
 * to specific methods in our server.
 * 
 * @author Daniel Langerenken
 */
@SuppressWarnings("serial")
public class DispatchServlet extends HttpServlet {

	/**
	 * This variable comes from JDispatcher an API by Helmar Hutschenreuter. The
	 * mapping of the URI's will be set with this variable. When this class gets
	 * initialized the dispatcher-variable will be configured and any incoming
	 * request from a client will be catched by the overriden "service"-method
	 * which handles ALL incoming methods "PUT,POST,GET etc."
	 * 
	 * a detailed usage-description is found at:
	 * http://carkowsky.informatik.uni-bremen.de/mobile4d/wiki/Server/Jdispatch
	 * */
	private Dispatcher dispatcher;

	/**
	 * This method gets automatically instantiated with its creation and setting
	 * to the server. The init-method is originally from the super-class of
	 * HttpServlet - from the super.super-class so to speak -.
	 * 
	 * @param config
	 *            the servlet config data
	 * @throws ServletException
	 */
	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);

		int sessionTimeout = new Gson().fromJson(PropertiesReader
				.getProperty(PropertiesReader.SESSION_TIMEOUT_PROPERTY),
				int.class);
		dispatcher = new Dispatcher(MSafeLogger.getLogger(),
				sessionTimeout * 60);

		createVoteResources(dispatcher);
		createTodayResources(dispatcher);
		createLastChanceResources(dispatcher);
		createFAQResources(dispatcher);
		createPreviousResources(dispatcher);
		createGeneralResources(dispatcher);
	}

	private void createGeneralResources(Dispatcher dispatcher2) {
		ResourceHandler generalHandler = dispatcher.registerResource("/",
				GeneralResource.class);
		generalHandler.registerRoutine(HttpMethod.GET, "refresh", "refresh");
	}

	private void createVoteResources(Dispatcher dispatcher2) {
		ResourceHandler voteHandler = dispatcher.registerResource("/vote/",
				VoteResource.class);
		voteHandler.registerRoutine(HttpMethod.GET, "", "info");
	}

	private void createTodayResources(Dispatcher dispatcher2) {
		ResourceHandler buyHandler = dispatcher.registerResource("/today/",
				TodayResource.class);
		buyHandler.registerRoutine(HttpMethod.GET, "", "info");
	}

	private void createLastChanceResources(Dispatcher dispatcher2) {
		ResourceHandler buyHandler = dispatcher.registerResource("/last/",
				LastChanceResource.class);
		buyHandler.registerRoutine(HttpMethod.GET, "", "info");
	}

	private void createFAQResources(Dispatcher dispatcher2) {
		ResourceHandler polygonHandler = dispatcher.registerResource("/faq/",
				FAQResource.class);
		polygonHandler.registerRoutine(HttpMethod.GET, "", "info");
	}

	private void createPreviousResources(Dispatcher dispatcher2) {
		ResourceHandler buildingHandler = dispatcher.registerResource(
				"/previous/", PreviousResource.class);
		buildingHandler.registerRoutine(HttpMethod.GET, "", "info");
	}

	/**
	 * This method comes from HttpServlet and handles any incoming REST-method.
	 * Normally there is no need to override this method but in our case the
	 * self-written API from Helmar does a different handling and so this is the
	 * central point for incoming requests.
	 * 
	 * @param request
	 * @param response
	 * @throws IOException
	 */
	@Override
	protected void service(HttpServletRequest request,
			HttpServletResponse response) throws IOException {
		if (request.getMethod().toUpperCase().equals("OPTIONS")) {
			PrintWriter out = response.getWriter();
			out.println("");
			out.close();
			return;
		}

		try {
			this.dispatcher.dispatch(request, response);
		} catch (UnexpectedException error) {
			Throwable cause = error.getCause();
			MSafeLogger.log(Level.WARNING, cause.getClass().getName() + ": "
					+ cause.getMessage(), cause);
			throw error; // Re-throw the exception to show an error page which
							// will be generated by Jetty.
		}
	}
}
